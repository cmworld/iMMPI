Decisions


1) Make separate classes implementing UITableViewDataSource that aren't  UIViewController subclasses.

    Reason:
        That would allow implementing a view controller subclass which is capable of displaying multiple types of lists (table views) and allows switchin between these types of lists. For example: a list of people with full names which could either fetch data from the database (thus requiring to show a list of Person objects) and from the Contacts app (a completely different behavior).
        
        We could either use a two UIViewController subclasses to implement that behavior, and combine these view controllers in a container view controller, or create a self-sufficient UITableViewDataSource implementation that is a subclass of NSObject, contain this data source in the desired UIViewController class and switch the table data sources when needed.
        
        The latter alternative seems to be easier to implement, since we are using storyboards in the project, and it would be probably hard to wire up the custom container controller for such a task, making the first alternative less convenient.
        
2) When using CoreDataTableController, set the dataSource of the corresponding table view to nil prior to fetching data, and set the dataSource property back to the CoreDataTableController instance if fetching succeeds.

    Reason:
        That actually just makes sense, since we do not have any data to display while the controller is fetching data (actual fetching would be performed only once at the first time the table view would be displayed - the later changes would be performed incrementally on the by-object basis without performing fetches).
        
        But the main reason why this decision had to be made is that the table view does actually call some of its dataSource methods before the CoreDataTableController even finished fetching. This is happening because we fetch data in background. A race condition actually appears in this case, so the table view could wait until the fetch finishes is one case and would not wait in another. If the table view tries to invoke data source methods before the fetch is finished, an index out of bounds exception is raised. To avoid this, we have to nullify the dataSource explicitly while the fetch is in progress.